# 🎄 미션 - 크리스마스 프로모션 🎄

> 우아한테크코스 프리코스 4주차

## 🚀 기능 목록

- [X] 식당 예상 방문 날짜 입력 기능 구현
    - [X] 12월 중 하루를 방문 날짜로 입력 받는다.
    - [X] ⚠️ 입력 값이 1 이상 31 이하의 숫자가 아닐 경우 예외 문구 처리 ⚠️

---

- [ ] 식당 방문 요일 계산 기능 구현
    - [ ] 입력 받은 방문 날짜에 해당하는 요일을 계산하여 확인한다.
    - [ ] 크리스마스 디데이 할인에 해당하는지 체크
    - [ ] 평일 할인과 주말 할인 중 어디에 해당하는지 체크
    - [ ] 특별 할인에 해당하는지 체크

---

- [ ] 주문 메뉴 및 개수 입력 기능 구현
    - [ ] 주문할 메뉴와 개수를 입력 받는다.
    - [ ] ⚠️ 입력 값이 빈 값일 경우 예외 문구 처리 ⚠️
    - [ ] ⚠️ 메뉴판에 없는 메뉴일 경우 예외 문구 처리 ⚠️
    - [ ] ⚠️ 메뉴의 개수가 1 이상의 숫자가 아닐 경우 예외 문구 처리 ⚠️
    - [ ] ⚠️ 메뉴 형식이 예시와 다른 경우 예외 문구 처리 ⚠️
    - [ ] ⚠️ 중복 메뉴를 입력할 경우 예외 문구 처리 ⚠️
    - [ ] ⚠️ 음료만 주문 시 예외 문구 처리 ⚠️
    - [ ] ⚠️ 한 번에 20개가 넘는 메뉴를 주문할 시 예외 문구 처리 ⚠️

---

- [ ] 주문 메뉴 출력 기능 구현
    - [ ] 주문한 메뉴 목록을 출력한다.
    - [ ] 출력 순서는 자유롭게 (이후 수정)

---

- [ ] 할인 전 총주문 금액 출력 기능 구현
    - [ ] 주문 메뉴들 가격을 합해 할인 전 총주문 금액을 출력한다.

---

- [ ] 증정 메뉴 출력 기능 구현
    - [ ] 할인 전 총주문 금액이 12만원 이상일 때, 샴페인을 1개 증정한다.
        - [ ] 12만원 미만일 경우 증정 이벤트에 해당하지 않으며, “없음”으로 표기한다.

---

- [ ] 할인 금액 계산 기능 구현
    - [ ] 할인 전 총주문 금액이 10,000원 이상일 때부터 할인 이벤트가 적용된다.
    - [ ] 크리스마스 디데이 할인 금액 계산
    - [ ] 평일/주말 할인 금액 계산
    - [ ] 특별 할인 금액 계산

---

- [ ] 혜택 내역 출력 기능 구현
    - [ ] 고객에게 적용된 이벤트 내역만 출력한다.
        - [ ] 적용된 이벤트가 하나도 없다면, “없음”으로 표기한다.
    - [ ] 혜택 금액은 -(금액)(단위)의 형식으로 표기한다. (ex. -1,000원)
    - [ ] 출력 순서는 자유롭게 (이후 수정)

---

- [ ] 총혜택 금액 출력 기능 구현
    - [ ] 총혜택 금액은 ‘할인 금액들의 합계 + 증정 메뉴의 가격’이다.
    - [ ] 혜택 해당 사항이 없을 경우, “0원”으로 표기한다.

---

- [ ] 할인 후 예상 결제 금액 출력 기능 구현
    - [ ] 할인 후 예상 결제 금액은 ‘할인 전 총주문 금액 - 할인 금액의 합계’이다.

---

- [ ] 이벤트 배지 출력 기능 구현
    - [ ] 총혜택 금액에 따라 다른 이벤트 배지를 부여하여 출력한다.
        - [ ] 5천 원 이상: 별
        - [ ] 1만 원 이상: 트리
        - [ ] 2만 원 이상: 산타
    - [ ] 이벤트 배지가 부여되지 않는 경우, “없음”으로 표기한다.

---

## ✅ 체크 리스트

- [ ] main 브랜치에 커밋했는지 확인
- [ ] JDK 17 버전에서 실행 가능한지 확인
- [ ] 출력값 형식 준수
- [ ] 주어진 테스트 모두 통과
- [ ] 프로그램 시작점 `Application`의 `main()` 준수
- [ ] `build.gradle` 변경 X
- [ ] 외부 라이브러리 사용 X
- [ ] Java 코드 컨벤션 가이드 준수
- [ ] 프로그램 종료 시 `System.exit()` 호출 X
- [ ] 요구 사항에서 명시하지 않은 파일, 패키지 변동 X
- [ ] indent(인덴트, 들여쓰기)의 depth가 3이 넘지 않도록 구현, 2까지만 허용됨.
- [ ] 3항 연산자 사용 X
- [ ] 함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현
    - [ ] 함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들기
- [ ] JUnit 5와 AssertJ를 이용한 테스트를 작성하여 위 기능 목록이 정상 동작함을 확인
- [ ] else 예약어 사용 X (if 조건절에서 return 방식을 사용하면 안 쓸 수 있음, switch / case도 X)
- [ ] 도메인 로직에 단위 테스트 구현
    - [ ] 핵심 로직 코드와 UI 담당 로직을 분리
- [ ] 사용자가 잘못된 값을 입력할 경우 [ERROR]로 시작하는 에러 메시지 출력 후 그 부분부터 재입력 받음.
    - [ ] 유형 처리를 명확히 함. (ex. `IllegalArgumentException`, `IllegalStateException` 등)

---

## 🚨 추가된 요구 사항

- [ ] 미션은[java-christmas-6](https://github.com/woowacourse-precourse/java-christmas-6)저장소를 비공개 저장소로 생성해 시작함.
- [ ] `InputView`, `OutputView` 같이 입력과 출력을 담당하는 클래스는 별도로 구현
    - [ ] 패키지, 클래스명, 메서드의 반환 타입과 시그니처는 자유롭게 구현 가능
- [ ] `camp.nextstep.edu.missionutils`의 `Console` API 사용
    - [ ] 사용자 입력 시 `camp.nextstep.edu.missionutils.Console`의 `readLine()`을 활용

---

## 📮 공통 피드백

- [ ] 1주차
    - [ ] 요구사항을 정확히 준수한다.
    - [ ] 커밋 메시지를 의미 있게 작성한다.
    - [ ] git을 통해 관리할 필요가 있는 자원인지에 대해 고려한다.
    - [ ] Pull Request를 보내기 전 브랜치를 확인한다.
    - [ ] PR을 한 번 작성했다면 닫지 말고 추가 커밋을 한다.
    - [ ] 이름을 통해 변수, 함수, 클래스의 역할에 대한 의도를 드러낸다.
    - [ ] 이름을 축약하지 않는다.
    - [ ] if, for, while문 사이의 공백도 코딩 컨벤션이므로 준수한다.
    - [ ] 공백 라인을 의미 있게 사용한다.
    - [ ] space와 tab을 혼용하지 않고 둘 중 하나만 사용한다.
    - [ ] 이름을 통해 의도가 드러난다면 굳이 의미 없는 주석을 달지 않는다.
    - [ ] IDE의 코드 자동 정렬 기능을 활용한다(⌥⌘L).
    - [ ] Java에서 제공하는 API를 적극 활용한다.
    - [ ] 배열 대신 Java Collection 자료구조를 사용한다.

---

- [ ] 2주차
    - [ ] README.md를 상세히 작성한다.
    - [ ] 기능 목록을 재검토한다.
    - [ ] 구현하면서 기능 목록 문서를 계속 업데이트한다.
    - [ ] 값을 하드 코딩하지 않는다.
    - [ ] 구현 순서도 코딩 컨벤션이므로 준수한다.
    - [ ] 변수 이름에 자료형을 사용하지 않는다.
    - [ ] 한 함수가 한 가지 기능만 담당하게 한다.
    - [ ] 함수가 한 가지 기능을 하는지 확인하는 기준을 세운다.
    - [ ] 테스트를 작성하는 이유에 대해 본인의 경험을 토대로 정리해본다.
    - [ ] 처음부터 큰 단위의 테스트를 만들지 않는다.

---

- [ ] 3주차
    - [ ] `main()` 함수에도 함수(메서드) 라인에 대한 기준을 적용한다.
    - [ ] 발생할 수 있는 예외 상황에 대해 고민한다.
    - [ ] 비즈니스 로직과 UI 로직을 분리한다.
        - [ ] View에서 사용할 데이터라면 getter 메서드를 통해 데이터를 전달한다.
    - [ ] 연관성이 있는 상수는 `static final` 대신 `enum`을 활용한다.
    - [ ] `final` 키워드를 사용해 값의 변경을 막는다.
    - [ ] 객체의 상태 접근을 제한한다.
        - [ ] 인스턴스 변수의 접근 제어자는 private으로 구현한다.
    - [ ] 객체는 객체스럽게 사용한다.
        - [ ] 데이터만 꺼내지(get) 말고 메시지를 던지도록 구조를 바꿔 데이터를 가진 객체가 일하도록 한다. (
          참고. https://tecoble.techcourse.co.kr/post/2020-04-28-ask-instead-of-getter/)
    - [ ] 필드(인스턴스 변수)의 수를 줄이기 위해 노력한다.
    - [ ] 성공하는 케이스 뿐만 아니라 예외에 대한 케이스도 테스트한다.
        - [ ] 경계값에서 결함이 자주 발생하므로 이 부분을 꼼꼼하게 확인한다.
    - [ ] 테스트 코드도 코드이므로 리팩터링을 통해 중복되는 부분이 없도록 개선한다.
    - [ ] 테스트를 위한 코드를 구현 코드에서 분리한다.
        - [ ] 테스트를 통과하기 위해 접근 제어자를 바꾸는 로직을 만들지 않는다.
        - [ ] 테스트를 통과하기 위해 테스트 코드에서만 사용되는 메서드를 만들지 않는다.
    - [ ] 단위 테스트하기 어려운 코드를 단위 테스트가 가능하게끔 리팩터링한다.
    - [ ] private 함수를 테스트 하고 싶다면 클래스(객체) 분리를 고려한다.
        - [ ] 너무 많은 역할을 하고 있는 함수나 객체를 어떻게 의미 있는 단위로 분할할지 고민한다.

---